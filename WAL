# ---------- 持久化相关方法（WAL + 原子快照） ----------
    def _ensure_data_dir(self):
        if not os.path.isdir(self.data_dir):
            try:
                os.makedirs(self.data_dir, exist_ok=True)
            except Exception:
                pass

    def _wal_append(self, entry: dict):
        """将操作追加到 WAL 并确保写入磁盘。"""
        with open(self.wal_path, "a", encoding="utf-8") as f:
            f.write(json.dumps(entry, ensure_ascii=False) + "\n")
            f.flush()
            os.fsync(f.fileno())

    def _atomic_write_json(self, path, obj):
        dirpath = os.path.dirname(path)
        fd, tmp = tempfile.mkstemp(dir=dirpath)
        try:
            with os.fdopen(fd, "w", encoding="utf-8") as tf:
                json.dump(obj, tf, ensure_ascii=False, indent=2)
                tf.flush()
                os.fsync(tf.fileno())
            os.replace(tmp, path)
        finally:
            if os.path.exists(tmp):
                try:
                    os.remove(tmp)
                except Exception:
                    pass

    def _atomic_write_pickle(self, path, obj):
        dirpath = os.path.dirname(path)
        fd, tmp = tempfile.mkstemp(dir=dirpath)
        try:
            with os.fdopen(fd, "wb") as tf:
                pickle.dump(obj, tf)
                tf.flush()
                os.fsync(tf.fileno())
            os.replace(tmp, path)
        finally:
            if os.path.exists(tmp):
                try:
                    os.remove(tmp)
                except Exception:
                    pass

    def _persist_state(self):
        """写入 contacts.json 和 trie.pkl 的原子快照，并在成功后清空 WAL。"""
        # 写 contacts
        try:
            self._atomic_write_json(self.contacts_path, {"contacts": self.contacts})
        except Exception as e:
            raise

        # 写 trie（pickle 序列化内存结构）
        try:
            self._atomic_write_pickle(self.trie_path, {"trie": self.trie, "suffix_trie": self.suffix_trie})
        except Exception:
            raise

        # 成功后清空 WAL（truncate）
        try:
            with open(self.wal_path, "w", encoding="utf-8") as f:
                f.truncate(0)
                f.flush()
                os.fsync(f.fileno())
        except Exception:
            pass

    def _load_state(self):
        """加载 contacts.json 与 trie.pkl（若存在）。"""
        # load contacts
        try:
            if os.path.exists(self.contacts_path):
                with open(self.contacts_path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                    self.contacts = data.get("contacts", [])
        except Exception:
            self.contacts = []

        # 更新 next_id 基准（确保 id 不会重复）
        try:
            max_id = 0
            for c in self.contacts:
                cid = c.get("id")
                if isinstance(cid, int) and cid > max_id:
                    max_id = cid
            if max_id >= self.next_id:
                self.next_id = max_id + 1
        except Exception:
            pass

        # load trie snapshot if exists
        try:
            if os.path.exists(self.trie_path):
                with open(self.trie_path, "rb") as f:
                    obj = pickle.load(f)
                    self.trie = obj.get("trie", self.trie)
                    self.suffix_trie = obj.get("suffix_trie", self.suffix_trie)
        except Exception:
            pass

    def _replay_wal(self):
        """读取并重放 WAL 中的操作（若存在），以恢复未完成事务。"""
        if not os.path.exists(self.wal_path):
            return
        try:
            with open(self.wal_path, "r", encoding="utf-8") as f:
                lines = [l.strip() for l in f if l.strip()]
        except Exception:
            return

        if not lines:
            return

        # 重放每一条操作
        for ln in lines:
            try:
                entry = json.loads(ln)
            except Exception:
                continue
            op = entry.get("op")
            data = entry.get("data", {})
            try:
                if op == "add":
                    # 使用 WAL 中的 id（若存在），避免重复添加
                    wid = data.get("id")
                    exists = any(c.get("id") == wid for c in self.contacts if wid is not None)
                    if not exists:
                        # 如果没有 id，则分配新 id
                        if wid is None:
                            wid = self.next_id
                            self.next_id += 1
                        else:
                            # 确保 next_id 大于已使用 id
                            if wid >= self.next_id:
                                self.next_id = wid + 1
                        contact = {"id": wid, "name": data.get("name"), "phone_number": data.get("phone_number"), "remark": data.get("remark")}
                        self.contacts.append(contact)
                        try:
                            self.trie.insert(contact.get("name"), contact.get("id"))
                        except Exception:
                            pass
                        try:
                            self.suffix_trie.insert(contact.get("phone_number"), contact.get("id"))
                        except Exception:
                            pass
                elif op == "delete":
                    cid = data.get("id")
                    contact = None
                    if cid is not None:
                        contact = next((c for c in self.contacts if c.get("id") == cid), None)
                    else:
                        # fallback by name
                        name = data.get("name")
                        contact = next((c for c in self.contacts if c.get("name") == name), None)
                    if contact:
                        try:
                            self.contacts.remove(contact)
                        except Exception:
                            pass
                        try:
                            self.trie.delete(contact.get("name"), contact.get("id"))
                        except Exception:
                            pass
                        try:
                            phone = contact.get("phone_number")
                            if phone:
                                self.suffix_trie.delete(phone, contact.get("id"))
                        except Exception:
                            pass
                elif op == "edit":
                    cid = data.get("id")
                    contact = None
                    if cid is not None:
                        contact = next((c for c in self.contacts if c.get("id") == cid), None)
                    else:
                        name = data.get("name")
                        contact = next((c for c in self.contacts if c.get("name") == name), None)
                    if contact:
                        new_name = data.get("new_name")
                        new_phone = data.get("new_phone")
                        new_remark = data.get("new_remark")
                        old_name = contact.get("name")
                        old_phone = contact.get("phone_number")
                        if new_name and new_name != old_name:
                            try:
                                self.trie.delete(old_name, contact.get("id"))
                            except Exception:
                                pass
                            try:
                                self.trie.insert(new_name, contact.get("id"))
                            except Exception:
                                pass
                            contact["name"] = new_name
                        if new_phone and new_phone != old_phone:
                            try:
                                if old_phone:
                                    self.suffix_trie.delete(old_phone, contact.get("id"))
                            except Exception:
                                pass
                            try:
                                self.suffix_trie.insert(new_phone, contact.get("id"))
                            except Exception:
                                pass
                            contact["phone_number"] = new_phone
                        if new_remark is not None:
                            contact["remark"] = new_remark
            except Exception:
                continue

        # 重放完成后，保存一次快照并清空 WAL
        try:
            self._persist_state()
        except Exception:
            pass
